#!/bin/bash

# get directory of this script
DIR="${BASH_SOURCE%/*}"
if [[ ! -d "$DIR" ]]; then DIR="$PWD"; fi

UTILS="$DIR/../util"

export FLAGS_TRUE="true"
export FLAGS_FALSE="true"

### defaults
FLAGS_nnode=2
FLAGS_ppn=2
FLAGS_time="00:20:00"

### Use associative array to declare how many arguments a long option
### expects, in this case we declare that loglevel expects/has one
### argument, long options that aren't listed in this way will have
### zero arguments by default
### (modified from http://mywiki.wooledge.org/ComplexOptionParsing)
declare -A longoptspec
longoptspec=( [nnode]=1,
              [ppn]=1,
              [freeze]=0,
              [verbose]=0,
              [time]=1,
              [partition]=1,
              [account]=1,
              [mpirun]=0,
            )
optspec=":h-:"
while getopts "$optspec" opt; do
while true; do
    case "${opt}" in
        -) #OPTARG is name-of-long-option or name-of-long-option=value
            if [[ "${OPTARG}" =~ .*=.* ]] #with this --key=value format only one argument is possible
            then
                opt=${OPTARG/=*/}
                OPTARG=${OPTARG#*=}
                ((OPTIND--))
            else #with this --key value1 value2 format multiple arguments are possible
                opt="$OPTARG"
                OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
            fi
            ((OPTIND+=longoptspec[$opt]))
            continue #now that opt/OPTARG are set we can process them as if getopts would've given us long options
            ;;
        nnode)
          FLAGS_nnode="${OPTARG}"
            ;;
        ppn)
          FLAGS_ppn="${OPTARG}"
            ;;
        freeze)
          FLAGS_freeze="${FLAGS_TRUE}"
            ;;
        verbose)
          FLAGS_nnode="${OPTARG}"
            ;;
        time)
          FLAGS_nnode="${OPTARG}"
            ;;
        partition)
          FLAGS_nnode="${OPTARG}"
            ;;
        account)
          FLAGS_nnode="${OPTARG}"
            ;;
        mpirun)
          FLAGS_mpirun="${FLAGS_TRUE}"
            ;;
        h|help)
            ###echo "usage: $0 [--loglevel[=]<value>]" >&2
            echo <<EOF
Usage: bin/grappa_run [options]
    -n, --nnode NODES                Number of nodes to run the Grappa job with
    -p, --ppn CORES                  Number of cores/processes per node
    -t, --time TIME                  Job time to pass to srun
    -e, --test TEST                  Run boost unit test program with given name (e.g. Aggregator_tests)
    -f, --[no-]freeze-on-error       Freeze all the jobs when there's an error
        --[no-]backtrace             Enable/disable GASNet's backtrace functionality.
    -v, --[no-]verbose               Verbose tests
        --partition P                Slurm partition to run on.
EOF
            exit 2
            ;;
    esac
break; done
done



# compute total number of MPI processes
totaln="$(( $FLAGS_nnode * $FLAGS_ppn ))"

# set freeze-on-error
[ ${FLAGS_freeze} -eq ${FLAGS_TRUE} ] && export GRAPPA_FREEZE_ON_ERROR=1

#TODO: test for if 'resv-ports' or 'OMPI_leave_pinned' should be set

#TODO: figure out way to set default Slurm partition (environment variable? make our own?)

if has_srun && [ $FLAGS_mpirun -eq $FLAGS_FALSE ]; then
  
  srun_flags=""
  
  [ -n "$FLAGS_partition" ] && srun_flags+=" --partition=$FLAGS_partition"
  [ -n "$FLAGS_account" ] && srun_flags+=" --account=$FLAGS_account"
  
  cmd="srun --cpu_bind=rank --label --kill-on-bad-exit --nodes=$FLAGS_nnode --ntasks-per-node=$FLAGS_ppn --time=$FLAGS_time $srun_flags -- $@"
  
else
  case `mpirun --version` in
    
  # OpenMPI v1.8
  mpirun*1.8*)
    [ $FLAGS_verbose -eq $FLAGS_TRUE ] && echo "# OpenMPI 1.8"
    cmd="mpirun --n $totaln --map-by ppr:$FLAGS_ppn:node -- $@"
    ;;
    
  # OpenMPI v < 1.8
  mpirun*1.*)
    cmd="mpirun --n $totaln --npernode $FLAGS_ppn -- $@"
    ;;
  
  *)
    echo "Unsupported version."
    exit 1
  esac
fi

# if verbose, echo command to be executed
[ $FLAGS_verbose -eq $FLAGS_TRUE ] && echo "# $cmd"

# setup environment variables
source "$UTILS/env.sh"
exec $cmd
